from flask import Flask, render_template, jsonify, send_file
import pandas as pd
import os
import glob
import subprocess
import threading
import time
from datetime import datetime

app = Flask(__name__)

# Global variables for capture control
capture_status = {"running": False, "progress": 0, "message": "Ready"}
auto_capture_thread = None

def run_ainet_auto():
    """Automatically run ainet.py and wait for completion"""
    global capture_status
    
    capture_status["running"] = True
    capture_status["message"] = "Starting ainet.py (network capture)..."
    capture_status["progress"] = 10
    
    try:
        print("Starting ainet.py...")
        
        # Start ainet.py as subprocess
        process = subprocess.Popen(
            ["python", "ainet.py"], 
            stdout=subprocess.PIPE, 
            stderr=subprocess.PIPE,
            universal_newlines=True
        )
        
        capture_status["message"] = "Capturing network traffic..."
        capture_status["progress"] = 30
        
        # Wait for process with timeout (30 seconds)
        start_time = time.time()
        timeout = 30
        
        while time.time() - start_time < timeout:
            if process.poll() is not None:
                # Process completed
                break
            
            # Update progress during wait
            elapsed = time.time() - start_time
            progress = 30 + (elapsed / timeout) * 60  # 30% to 90%
            capture_status["progress"] = min(90, int(progress))
            capture_status["message"] = f"Capturing... ({int(elapsed)}s elapsed)"
            
            time.sleep(1)
        
        # Check if process is still running after timeout
        if process.poll() is None:
            print("Process timeout reached, terminating...")
            process.terminate()
            try:
                process.wait(timeout=5)  # Wait up to 5 seconds for clean termination
            except subprocess.TimeoutExpired:
                process.kill()  # Force kill if still running
            capture_status["message"] = "Capture completed (timeout reached)"
        else:
            # Process completed normally
            stdout, stderr = process.communicate()
            if process.returncode == 0:
                capture_status["message"] = "Capture completed successfully!"
                print("ainet.py completed successfully")
                if stdout:
                    print(f"Output: {stdout}")
            else:
                capture_status["message"] = f"Capture completed with errors (code: {process.returncode})"
                print(f"ainet.py finished with return code: {process.returncode}")
                if stderr:
                    print(f"Error: {stderr}")
        
        capture_status["progress"] = 100
        
        # Wait a moment then auto-load the latest file
        time.sleep(2)
        print("Capture process finished")
        
    except FileNotFoundError:
        capture_status["message"] = "Error: ainet.py not found in current directory"
        print("Error: Could not find ainet.py")
    except Exception as e:
        capture_status["message"] = f"Error running capture: {str(e)}"
        print(f"Error running ainet.py: {e}")
    finally:
        capture_status["running"] = False

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/start_auto_capture')
def start_auto_capture():
    """Start automatic capture using ainet.py"""
    global auto_capture_thread
    
    if capture_status["running"]:
        return jsonify({"status": "already_running", "message": "Capture already in progress"})
    
    auto_capture_thread = threading.Thread(target=run_ainet_auto)
    auto_capture_thread.daemon = True
    auto_capture_thread.start()
    
    return jsonify({"status": "started", "message": "Started automatic capture"})

@app.route('/capture_status')
def get_capture_status():
    """Get current capture status"""
    return jsonify(capture_status)

@app.route('/scan_files')
def scan_files():
    """Scan for existing CSV files generated by ainet.py"""
    csv_files = glob.glob("network_traffic_*.csv")
    
    if not csv_files:
        return jsonify({"message": "No CSV files found. Run capture first to generate data.", "files": []})
    
    # Sort files by modification time (newest first)
    csv_files.sort(key=os.path.getmtime, reverse=True)
    
    file_info = []
    for file in csv_files:
        try:
            # Get file info
            mod_time = os.path.getmtime(file)
            file_size = os.path.getsize(file)
            
            # Quick peek at data
            df = pd.read_csv(file)
            packet_count = len(df)
            threats = len(df[df["Threat Classification"] == "Threat"]) if "Threat Classification" in df.columns else 0
            
            file_info.append({
                "filename": file,
                "modified": datetime.fromtimestamp(mod_time).strftime('%Y-%m-%d %H:%M:%S'),
                "size_kb": round(file_size / 1024, 2),
                "packets": packet_count,
                "threats": threats
            })
        except Exception as e:
            print(f"Error reading {file}: {e}")
    
    return jsonify({"message": f"Found {len(file_info)} CSV files", "files": file_info})

@app.route('/get_latest_file')
def get_latest_file():
    """Get the most recently created CSV file"""
    csv_files = glob.glob("network_traffic_*.csv")
    
    if not csv_files:
        return jsonify({"error": "No CSV files found"})
    
    # Get the newest file
    latest_file = max(csv_files, key=os.path.getctime)
    return jsonify({"filename": latest_file})

@app.route('/load_file/<filename>')
def load_file(filename):
    """Load and display specific CSV file data"""
    if not filename.startswith("network_traffic_") or not filename.endswith(".csv"):
        return jsonify({"error": "Invalid filename"})
    
    if not os.path.exists(filename):
        return jsonify({"error": "File not found"})
    
    try:
        df = pd.read_csv(filename)
        
        # Get summary statistics
        total_packets = len(df)
        threats = len(df[df["Threat Classification"] == "Threat"]) if "Threat Classification" in df.columns else 0
        safe_packets = total_packets - threats
        
        # Protocol distribution
        protocols = df["Protocol"].value_counts().to_dict() if "Protocol" in df.columns else {}
        
        # Source/Destination analysis
        top_sources = df["Source"].value_counts().head(5).to_dict() if "Source" in df.columns else {}
        top_destinations = df["Destination"].value_counts().head(5).to_dict() if "Destination" in df.columns else {}
        
        # Threat analysis
        threat_data = df[df["Threat Classification"] == "Threat"] if "Threat Classification" in df.columns else pd.DataFrame()
        threat_protocols = threat_data["Protocol"].value_counts().to_dict() if len(threat_data) > 0 else {}
        
        return jsonify({
            "filename": filename,
            "total_packets": total_packets,
            "threats_detected": threats,
            "safe_packets": safe_packets,
            "safety_rate": round((safe_packets / total_packets) * 100, 1) if total_packets > 0 else 100,
            "protocols": protocols,
            "top_sources": top_sources,
            "top_destinations": top_destinations,
            "threat_protocols": threat_protocols,
            "data": df.to_dict('records'),  # All data for table
            "threat_data": threat_data.to_dict('records') if len(threat_data) > 0 else []
        })
    
    except Exception as e:
        return jsonify({"error": f"Error loading file: {str(e)}"})

@app.route('/download/<filename>')
def download_file(filename):
    """Download CSV file"""
    if filename.startswith("network_traffic_") and filename.endswith(".csv") and os.path.exists(filename):
        return send_file(filename, as_attachment=True)
    return "File not found", 404

@app.route('/delete/<filename>')
def delete_file(filename):
    """Delete CSV file"""
    if filename.startswith("network_traffic_") and filename.endswith(".csv") and os.path.exists(filename):
        try:
            os.remove(filename)
            return jsonify({"message": f"File {filename} deleted successfully"})
        except Exception as e:
            return jsonify({"error": f"Error deleting file: {str(e)}"})
    return jsonify({"error": "File not found"}), 404

if __name__ == '__main__':
    print("=== AI Network Threat Detection System ===")
    print("1. Auto-runs ainet.py when 'Start Capture' is clicked")
    print("2. Waits up to 30 seconds for completion")
    print("3. Automatically displays results")
    print("4. Open browser: http://127.0.0.1:5000")
    print("5. Make sure ainet.py is in the same directory")
    app.run(debug=True, host='127.0.0.1', port=5000, threaded=True)
